{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Overview","text":""},{"location":"#permitta-makes-using-opa-with-trino-simple-and-fun","title":"Permitta makes using OPA with Trino simple and fun","text":"<p>OPA and Trino are an awesome combination, but maintaining the policy documents and required data object can be painful. Permitta makes this easy with managed curation of principals, catalogs, schemas, tables and columns, as well as their associated ABAC attributes.</p> <p>Permitta provides an API to serve bundles to OPA, including:</p> <ul> <li>Data objects and attributes ingested from various sources (SQL DBs,data catalogs etc)</li> <li>Principals and attributes/groups ingested from identity providers (SQL DB, LDAP, etc)</li> <li><code>Rego</code> policy documents created in the visual builder or DSL editor</li> </ul>"},{"location":"#architecture","title":"Architecture","text":""},{"location":"#motivation","title":"Motivation","text":"<p>In late 2023 Open Policy Agent (OPA) was introduced into Trino as an authentication method. OPA is a very powerful policy enforcement engine which helps to solve many authorisation issues with the previously available  authorisation options in Trino. </p> <p>OPA provides the capability to implement very fine-grained R/ABAC policies to control access to data in Trino. OPA policies can control access at the catalog, schema, table or column level and provide column masking. </p> <p>OPA policies are defined in a language called Rego. While it is an expressive and powerful language, it has a steep learning curve and limits policy definition to users with software development skills. It is expected that users within  many organisations who are tasked with data policy definition do not possess these types of skills.</p> <p>OPA also requires context on the principals and objects, such as attributes or group mappings. This must be provided to OPA as a (possibly) large JSON object, and updated whenever these values change.  </p> <p>While extremely powerful, OPA is hard to use for non-developers, and has a significant integration cost. </p> <p>Permitta simplifies the use of OPA with Trino by:</p> <ul> <li>Providing a simple drag-and drop policy builder</li> <li>Aggregating metadata from sources such as <code>Active Directory</code></li> <li>Delivering bundles of policy and context metadata to instances of OPA</li> </ul>"},{"location":"#trino-opa-operation","title":"Trino / OPA Operation","text":"<p>When an SQL statement is supplied to Trino for execution, it executes a (potentially) large number of authorisation  checks. Each of these authorisation checks includes an action, a subject and an object. The subject is the user executing the query, and the object is the catalog, schema or table. </p> <p>Upon receiving an authorisation request OPA executes tests defined in the policy document using an input variable  provided by Trino, against the data in the context data object.</p> <p>For example, a user executes a simple query:</p> <p><code>SELECT a, b, c from datalake.hr.employees</code></p> <p>This results in many requests to OPA, one of which checks if this user (alice)  is allowed to select these columns:</p> <pre><code>{\n  \"context\": {\n    \"identity\": {\n      \"user\": \"alice\"\n    }\n  },\n  \"action\": {\n    \"operation\": \"SelectFromColumns\",\n    \"resource\": {\n      \"table\": {\n        \"catalogName\": \"datalake\",\n        \"schemaName\": \"hr\",\n        \"tableName\": \"employees\",\n        \"columns\": [\"a\", \"b\", \"c\"]\n      }\n    }\n  }\n}\n</code></pre>"},{"location":"#policy-implementation","title":"Policy Implementation","text":"<p>To implement ABAC policies with OPA, we require a <code>data</code> object containing the <code>principals</code>  and <code>data-objects</code> (schemas, tables, columns etc) as well at attributes or groups for each.  OPA uses the information in the <code>data</code> object, along with <code>input</code> object to enforce the rules defined in the rego policy document.</p>"},{"location":"#example-rego-policy-document","title":"Example Rego Policy Document","text":"<p>This policy ensures that any user who exists in our data object is allowed to <code>SELECT</code> from any table in the <code>datalake</code> catalog, as long as the schema is in our data object.  All other operations on any other object will be denied</p> <pre><code>package permitta.trino\n\nimport rego.v1\nimport data.trino\n\nallow if {\n  # action is SELECT\n  input.action.operation == \"SelectFromColumns\"\n\n  # user exists in our data object\n  some principal in data.trino.principals\n  principal.name == input.context.identity.user\n\n  # catalog is datalake\n  input.action.resource.table.catalogName == \"datalake\"\n\n  # schema is in our data object\n  some schema in data.trino.schemas\n  schema.name == input.action.resource.table.schemaName\n}\n</code></pre>"},{"location":"#example-data-object","title":"Example Data object","text":"<pre><code>{ \n  \"principals\": [\n    {\n      \"name\": \"alice\"\n    },\n    {\n      \"name\": \"bob\"\n    }\n  ],\n  \"schemas\": [\n    {\n      \"name\": \"hr\"\n    }\n  ]\n}\n\n</code></pre>"},{"location":"developer_setup/","title":"Developer Setup","text":""},{"location":"developer_setup/#install-dependencies","title":"Install Dependencies","text":"<ul> <li><code>venv</code> and <code>node_modules</code> should both be at the project root</li> <li>requires local installation of OPA, python 3.12 and a recent version of nodejs</li> <li>supporting apps run under docker-compose</li> <li>an SQL client (e.g: dbeaver) is also required</li> </ul> <pre><code>brew install opa\nbrew install nodejs\nbrew install python@3.12\n\npython3.12 -m venv venv\nsource venv/bin/activate\npip install -r requirements.txt\n\n# front end\ncd permitta/ui\nnpm install\nnpm start   # watches both the js folder and tailwind\n</code></pre>"},{"location":"developer_setup/#formatting","title":"Formatting","text":"<pre><code># in project root\nisort --profile black permitta/src\nblack permitta/src\n</code></pre>"},{"location":"developer_setup/#running-the-dev-environment","title":"Running the dev environment","text":"<ul> <li>Run flask on 8000, or it clashes with airplay</li> <li>Set the following environment variables</li> </ul>"},{"location":"developer_setup/#webapp-environment-variables","title":"Webapp Environment Variables","text":"Name Purpose FLASK_SECRET_KEY Encrypts the cookies - use a complex, cryptographically secure string OIDC_AUTH_PROVIDER_CLIENT_SECRET The client secret provided by the OIDC server (keycloak) - in docker/keycloak/permitta_realm.json"},{"location":"developer_setup/#starting-the-dev-server","title":"Starting the dev server","text":"<pre><code># run dependencies\ndocker-compose up -d\n\n# populate LLDAP:\ndocker compose exec lldap /bootstrap/bootstrap.sh\n\nexport PYTHONPATH=permitta/src\nflask --app permitta.src.app run --debug --port 8000\n\n# seed the database\npython permitta/permitta/src/seed_db.py\n\n# nuking a bad flask process\nkill $(pgrep -f flask)\n</code></pre>"},{"location":"developer_setup/#documentation","title":"Documentation","text":"<p>Docs are provided by <code>mkdocs</code> using the <code>mkdocs-material</code> theme.</p> <pre><code># render docs for development\nmkdocs serve\n\n# build docs\nTBA\n</code></pre>"},{"location":"config/configuration/","title":"Configuration File","text":"<p>All configuration items are defined in a yaml file provided to the application. The location of this file is defined by an environment variable called  <code>CONFIG_FILE_PATH</code>. The value of this variable should be an absolute path.</p> <p>The yaml file is a flat structure, with all keys at the top level. E.g:</p> <pre><code>ldap_client.host: localhost\nldap_client.port: \"3890\"\nldap_client.base_dn: dc=example,dc=com\nldap_client.user_dn: uid=admin,ou=people,dc=example,dc=com\n</code></pre>"},{"location":"config/configuration/#environment-variables","title":"Environment Variables","text":"<p>If environment variables are preferred for some configuration items (e.g secrets) these can be referenced in the configuration file using a bash-style syntax. These values will be retrieved from the environment and included in the configuration object at runtime.</p> <pre><code>ldap_client.password: $LDAP_PASSWORD \nldap_client.user_dn: uid=$LDAP_UID,ou=people,dc=example,dc=com\n</code></pre>"},{"location":"config/properties_ldap_client/","title":"LDAP Client Properties","text":"<p>These properties configure the LDAP client which is used to ingest principals.</p>"},{"location":"config/properties_ldap_client/#ldap_clienthost","title":"<code>ldap_client.host</code>","text":"<ul> <li>Type: <code>url</code></li> <li>Default: <code>&lt;none&gt;</code></li> <li>Example: <code>ldap.domain.com</code></li> </ul>"},{"location":"config/properties_ldap_client/#ldap_clientport","title":"<code>ldap_client.port</code>","text":"<ul> <li>Type: <code>string</code></li> <li>Default: <code>&lt;none&gt;</code></li> <li>Example: <code>3890</code></li> </ul>"},{"location":"config/properties_ldap_client/#ldap_clientuser_dn","title":"<code>ldap_client.user_dn</code>","text":"<ul> <li>Type: <code>string</code></li> <li>Default: <code>&lt;none&gt;</code></li> <li>Example: <code>uid=admin,ou=people,dc=example,dc=com</code></li> </ul>"},{"location":"config/properties_ldap_client/#ldap_clientpassword","title":"<code>ldap_client.password</code>","text":"<ul> <li>Type: <code>string</code></li> <li>Default: <code>&lt;none&gt;</code></li> <li>Example: <code>$LDAP_PASSWORD</code></li> </ul>"},{"location":"config/properties_ldap_client/#ldap_clientbase_dn","title":"<code>ldap_client.base_dn</code>","text":"<ul> <li>Type: <code>string</code></li> <li>Default: <code>&lt;none&gt;</code></li> <li>Example: <code>dc=example,dc=com</code></li> </ul>"},{"location":"config/properties_ldap_client/#ldap_clientuser_base_dn","title":"<code>ldap_client.user_base_dn</code>","text":"<ul> <li>Type: <code>string</code></li> <li>Default: <code>&lt;none&gt;</code></li> <li>Example: <code>ou=people,dc=example,dc=com</code></li> </ul>"},{"location":"config/properties_logging/","title":"Logging Properties","text":""},{"location":"config/properties_logging/#loggingroot_level","title":"<code>logging.root_level</code>","text":"<ul> <li>Type: <code>enum</code></li> <li>Values: <code>DEBUG</code>, <code>INFO</code>, <code>WARN</code>, <code>ERROR</code></li> <li>Default: <code>INFO</code></li> <li>Example: <code>DEBUG</code></li> </ul> <p>Sets the log level of the root logger. This applies to all loggers within Permitta as they all inherit from the root logger</p>"},{"location":"config/properties_oidc/","title":"OIDC Properties","text":"<p>When an OIDC provider (e.g <code>KeyCloak</code>, <code>OKTA</code>) is configured for permitta, the client properties the issuer URL, client ID and client secret should be created.</p>"},{"location":"config/properties_oidc/#oidc_auth_providerissuer","title":"<code>oidc_auth_provider.issuer</code>","text":"<ul> <li>Type: <code>url</code></li> <li>Default: <code>&lt;none&gt;</code></li> <li>Example: <code>http://localhost:8080/realms/permitta</code></li> </ul>"},{"location":"config/properties_oidc/#oidc_auth_providerclient_id","title":"<code>oidc_auth_provider.client_id</code>","text":"<ul> <li>Type: <code>string</code></li> <li>Default: <code>&lt;none&gt;</code></li> <li>Example: <code>permitta_client</code></li> </ul>"},{"location":"config/properties_oidc/#oidc_auth_providerclient_secret","title":"<code>oidc_auth_provider.client_secret</code>","text":"<ul> <li>Type: <code>secret string</code></li> <li>Default: <code>&lt;none&gt;</code></li> <li>Example: <code>$OIDC_CLIENT_SECRET</code></li> </ul>"},{"location":"config/properties_oidc/#oidc_auth_providerredirect_uri","title":"<code>oidc_auth_provider.redirect_uri</code>","text":"<ul> <li>Type: <code>string</code></li> <li>Default: <code>&lt;none&gt;</code></li> <li>Example: <code>http://permitta.domain.com/oidccallback</code></li> </ul> <p>The <code>redirect_uri</code> is the location to which the OIDC service will redirect the user after a successful login. It should route to <code>/oidccallback</code> on Permitta.</p>"},{"location":"config/properties_opa_authz/","title":"OPA Authorisation Properties","text":"<p>On startup, Permitta pushes a <code>rego</code> policy document to OPA. This document contains the rules for authorisation within Permitta.</p> <p>These properties define the name and location of the <code>rego</code> document which is provided to OPA. This document can be replaced by the developer, allowing a high level of flexibility of authorisation.</p>"},{"location":"config/properties_opa_authz/#opa_authz_providerpolicy_name","title":"<code>opa_authz_provider.policy_name</code>","text":"<ul> <li>Type: <code>string</code></li> <li>Default: <code>permitta/authz</code></li> <li>Example: <code>permitta/authz</code></li> </ul>"},{"location":"config/properties_opa_authz/#opa_authz_providerpolicy_file_path","title":"<code>opa_authz_provider.policy_file_path</code>","text":"<ul> <li>Type: <code>string</code></li> <li>Default: <code>&lt;none&gt;</code></li> <li>Example: <code>opa/permitta/authz.rego</code></li> </ul>"},{"location":"config/properties_opa_authz/#opa-connectivity-properties","title":"OPA Connectivity Properties","text":"<p>These properties control the connectivity to the OPA instance used for authorisation of actions within the Permitta UI and APIs. This can be the same instance used by <code>trino</code>, however it is  recommended that Permitta has a dedicated instance.</p>"},{"location":"config/properties_opa_authz/#opa_clientscheme","title":"<code>opa_client.scheme</code>","text":"<ul> <li>Type: <code>enum</code></li> <li>Values: <code>https</code>, <code>http</code></li> <li>Default: <code>&lt;none&gt;</code></li> <li>Example: <code>https</code></li> </ul> <p>For production deployments, HTTPS should be used everywhere.</p>"},{"location":"config/properties_opa_authz/#opa_clienthostname","title":"<code>opa_client.hostname</code>","text":"<ul> <li>Type: <code>string</code></li> <li>Default: <code>localhost</code></li> <li>Example: <code>opa.permitta.svc.cluster.local</code></li> </ul> <p>The hostname of the OPA instance that Permitta should connect to</p>"},{"location":"config/properties_opa_authz/#opa_clientport","title":"<code>opa_client.port</code>","text":"<ul> <li>Type: <code>string</code></li> <li>Default: <code>8181</code></li> <li>Example: <code>8181</code></li> </ul>"},{"location":"config/properties_opa_authz/#opa_clientpath","title":"<code>opa_client.path</code>","text":"<ul> <li>Type: <code>path</code></li> <li>Default: <code>/v1/data/permitta/authz/allow</code></li> <li>Example: <code>/v1/data/permitta/authz/allow</code></li> </ul>"},{"location":"config/properties_opa_authz/#opa_clienttimeout_seconds","title":"<code>opa_client.timeout_seconds</code>","text":"<ul> <li>Type: <code>string</code></li> <li>Default: <code>1</code></li> <li>Example: <code>10</code></li> </ul>"},{"location":"policies/builder/","title":"Visual Policy Builder","text":"<p>One of the core features of Permitta is the policy builder. This provides a visual drag-and-drop style interface for creating and maintaining attribute-based policies.</p> <p>Builder Policies in Permitta are best considered as an entity which selects a  group of principals, and a group of objects. Think of a venn diagram with two sets, one being principals and the other being objects. The intersection (overlap) between these sets represents the access provided by the policy.</p> <p>It is important to understand that increasing the number of attributes assigned to a policy serves to reduce its scope. This is because a builder policy selects principals or objects which have all attributes. </p> <p>Policies are defined by the attributes assigned to them, rather than the objects and principals which are selected by them. This means that policies are applied dynamically, and any new users or objects introduced will be automatically included in the policy if they are assigned the requisite attributes.</p>"},{"location":"policies/builder/#principal-selection","title":"Principal Selection","text":""},{"location":"policies/builder/#available-principal-attributes-pane","title":"Available Principal Attributes Pane","text":"<p>The upper-left pane includes all principal attributes that Permitta is aware of.  This is an exhaustive list of attributes currently assigned to principals which permitta has ingested.</p>"},{"location":"policies/builder/#required-principal-attributes-pane","title":"Required Principal Attributes Pane","text":"<p>Attributes can be dragged-and-dropped into this pane to form the policy. The policy will select all principals who possess all of the  </p>"},{"location":"policies/builder/#principals-list-pane","title":"Principals List Pane","text":"<p>The lower pane shows the list of principals who are included in this policy along with their attributes.</p>"},{"location":"policies/builder/#data-object-selection","title":"Data Object Selection","text":"<p>Data object selection operates in a similar manner to the principal selection view. Attributes can be dragged from the left-hand pane to the right, and in doing so, the list of applicable objects is extended or reduced dynamically.</p> <p></p>"},{"location":"policies/dsl_editor/","title":"DSL Editor","text":"<p>The DSL editor provides an IDE where <code>rego</code> code can be written and modified  within Permitta. Each DSL policy consists of a <code>rego</code> snippet, which is compiled into a complete policy document along with the content of the builder policies.</p> <p>The IDE is based on <code>codemirror</code> and includes formatting and syntax highlighting.</p> <p>Policy workflows apply to policies defined using the DSL editor, in the same way as builder policies.</p> <p>Future feature: Rego evaluation and linting via OPA APIs</p> <p></p>"},{"location":"policies/listing/","title":"Policy Management","text":"<p>The main interactive feature in the Permitta UI is the policy editor. In this interface, a user can create, modify, or request publish or deletion of a policy.</p> <p>Policies in Permitta take two main forms, <code>Builder</code> and <code>DSL</code>.</p>"},{"location":"policies/listing/#builder-policies","title":"Builder Policies","text":"<p>Builder policies are created using a drag-and-drop interface. Simple <code>AND</code> logic is implemented within builder policies and policies are OR'ed together. This method creates a safe means of policy modification, as highly specific  policies can be  added without risk of impacting existing consumers. This makes Permitta's builder policies very easy to understand and build.</p>"},{"location":"policies/listing/#dsl-policies","title":"DSL Policies","text":"<p>DSL policies provide an interface to write and edit <code>Rego</code> code directly. This  allows for highly nuanced policies to be created by power users. This way, Permitta does not restrict users from enabling the full functionality of OPA, but retains  the UI and approval workflow.</p> <p>See Policies for more information on policy workflows</p>"},{"location":"policies/listing/#policy-listing","title":"Policy Listing","text":"<p>The policy listing presents all policies created in Permitta, along with their policy type (DSL or Builder) and state.</p> <p>From this view, users can view or modify content and state of the policies.</p> <p></p>"},{"location":"policies/listing/#policy-workflow","title":"Policy Workflow","text":"<p>A policy in Permitta has an associated state.  The policy workflow defines which states a policy can move to, depending on its current state.</p> <p>Only policies which are in <code>Published</code> or <code>Pending Disable</code> are included in the bundle provided to OPA/Trino.</p>"},{"location":"policies/listing/#possible-next-states","title":"Possible Next States","text":"State Description Possible next states Draft A new policy which currently has no effect Pending Publish, Deleted Pending Publish A policy which is waiting on approval of an owner Published, Draft Published A live policy which affects users Pending Disable Pending Disable A live policy which is waiting on approval to deactivate Published, Disables Disabled A policy which was published, but now has no effect Deleted, Pending Publish Deleted A policy which has been marked deleted <p>User permissions for state transitions are defined in a <code>rego</code> document. This provides a high degree of flexibility when assigning which users can make which changes. See Auth for more information.</p>"},{"location":"security/auth/","title":"Authentication &amp; Authorisation","text":""},{"location":"security/auth/#web-authentication","title":"Web Authentication","text":"<p>Currently the only available method for authenticating a web user is OIDC. This method should work for all OIDC providers</p> <p>See here for configuration options</p>"},{"location":"security/auth/#api-authentication","title":"API Authentication","text":"<p>APIs are authenticated using an API key which can be generated via the CLI See TBA for documentation</p>"},{"location":"security/auth/#authorisation","title":"Authorisation","text":"<p>Authorisation within Permitta is governed by OPA (surprise!). A default rego document and policy paradigm is included. Every HTTP request is authorised, and OPA receives the following payload for each:</p> <pre><code>{\n    \"action\": \"READ\",\n    \"subject\": {\n        \"username\": \"alice\",\n        \"attributes\": [\n            {\"key\": \"HR\", \"value\": \"Commercial\"},\n            {\"key\": \"HR\", \"value\": \"Privacy\"}\n        ]\n    },\n    \"object\": {\n        \"type\": \"POLICY\",\n        \"state\": \"draft\",\n        \"attributes\": [{\"key\": \"IT\", \"value\": \"Commercial\"}]\n    }\n}\n</code></pre> <p>Each payload includes all attributes of the user and the object as well as the action performed.  Custom rego policies can be supplied to allow very fine-grained and arcane policies to be created,  according to the specific needs of your organisation.</p>"},{"location":"security/auth/#default-authorisation-paradigm","title":"Default Authorisation Paradigm","text":"<p>The motivations for the supplied auth-n process are: * Separation of responsibilities - no one person should be able to make an access change alone * Delegation - certain individuals are best placed to assign access to specific objects (i.e domain experts)</p>"},{"location":"security/auth/#definitions","title":"Definitions","text":"<p>Domain/Subject &amp; Label:  Domains or subjects refer to the <code>key</code> part of attributes applied to objects or principals e.g: The attribute <code>HR:Commercial</code> has the domain or subject <code>HR</code> and the label <code>Commercial</code> </p>"},{"location":"security/auth/#default-policies","title":"Default Policies","text":"<p>Permitta ships with a default RABAC policy with the following paradigm</p> <ul> <li>Read access is granted for all users on all things</li> <li>A user with the attribute <code>permitta_role:admin</code> has full access to do anything</li> <li>Policies for other users are RABAC in the sense that they acquire a role by owning an attribute, but still require other attributes to change certain objects</li> <li>Roles are granted via attributes, default attribute names can be updated in the rego, or inherited via attribute groups</li> </ul>"},{"location":"security/auth/#roles","title":"Roles","text":"Role Name Membership Attribute Access Level Administrator <code>permitta_role:admin</code> All actions on all objects Policy Maintainer <code>permitta_role:maintainer</code> Can author all policies dependant on their state Domain/Subject Owner <code>HR:owner</code> Can approve the publish or deactivation policies which contain <code>HR</code> tags"},{"location":"security/auth/#policy-maintainer","title":"Policy Maintainer","text":"<p>The role of the policy maintainer is to author policies to provide the specific authorisation requirements. The maintainer cannot make policy changes which affect users (i.e they cannot publish or deactivate a policy). Maintainers can request publishing of draft policies, or request deactivation of existing published policies.</p>"},{"location":"security/auth/#domainsubject-owner","title":"Domain/Subject Owner","text":"<p>The role of the owner is to approve the publishing of draft policies and deactivation of published policies. An owner can also be a maintainer, allowing them to author policies as well as approve them, however to provide separation of responsibilities, no user can approve a policy they have authored. Therefore it is required that there is at least one owner and one separate maintainer per domain/subject. </p> <p>A user can be the owner of multiple domain/subjects, allowing them to approve cross-domain policy changes.  For more information, see Policy Management</p>"}]}